import h5py
import numpy as np
import argparse

def read_box_edges(args):
    with h5py.File(args.input, "r") as f_in:
        dataset = f_in["/particles/fluid/box/edges"]
        box = np.array(f_in[dataset])[()]
        return box

def wrap_pbc(positions, box_edges):
    """
    Wraps coordinates into the centered box [-L/2, L/2].
    """
    # Extract diagonal L from box edges
    L = np.diag(box_edges)

    return ((positions + L/2) % L) - L/2

def read_positions(args, time_step, box):
    with h5py.File(args.input, "r") as f_in:
        dataset = np.array(f_in["/particles/fluid/position/value"])
        if time_step >= dataset.shape[0]:
            print(f"Warning: Time Step {time_step} is out of bounds.")
            return None

        pos_fluid = dataset[time_step]

    pos_fluid_wrapped = wrap_pbc(pos_fluid, box)
    species_fluid = ["F"] * pos_fluid.shape[0]

    n_atoms = pos_fluid.shape[0]

    particle_dict = {"positions" : pos_fluid_wrapped,
                     "num_atoms" : n_atoms,
                     "species" : species_fluid
                     }
    return particle_dict

def write_positions_xyz(args, particle_dict):
    with open(args.output, "a") as f_out:
        f_out.write(f"{particle_dict['num_atoms']}\n")
        f_out.write("Generated by h5_to_xyz.py\n")

        for atom, pos in zip(particle_dict["species"], particle_dict["positions"]):
            f_out.write(f"{atom} {pos[0]:.6f} {pos[1]:.6f} {pos[2]:.6f}\n")

def traj_count(args):
    with h5py.File(args.input, "r") as f_in:
        dataset = np.array(f_in["/particles/fluid/position/value"])
        return dataset.shape[0]


def main():

    parser = argparse.ArgumentParser(description="Read positions from H5\
            simulation file and write in XYZ format")
    #Required Arguments:
    parser.add_argument("--input", required=True, help="H5 input path to read positions from")
    parser.add_argument("--output", requrired=True, help="XYZ output path")

    #Optional Arguments:
    parser.add_argument("--range", type=int, nargs=2, default=[0, -1], help="Range of simulation snapshots to read")
    parser.add_argument("--every", type=int, default=1, help="Read every x steps")

    args = parser.parse_args()

    open(args.output, 'w').close()

    start_frame, end_frame = args.range
    if end_frame == 1:
        end_frame = traj_count(args)

    box = read_box_edges(args)

    print(f"Converting frames {start_frame} to {end_frame} every {args.every} steps...")

    count = 0
    for t in range(start_frame, end_frame, args.every):
        data = read_positions(args, time_step=t, box = box)
        if data is not None:
            write_positions_xyz(args, data)
            count += 1
            if count % 100 == 0:
                print(f"Processed {count} frames...", end='\r')

    print(f"\nDone! Extracted {count} frames to {args.output}")

if __name__ == "__main__":
    main()



